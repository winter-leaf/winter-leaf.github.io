<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/ico32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/ico16x16.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Liu Jian Mao Cao:300,300italic,400,400italic,700,700italic|Shadows Into Light:300,300italic,400,400italic,700,700italic|Yeon Sung:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"7.5.0",exturl:!1,sidebar:{position:"left",width:300,display:"hide",offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"},sidebarPadding:40}</script><meta name="description" content="很多人在做Xprop仿真的时候大都是对仿真器加入一个选项，然后就跑仿真模型了，有了问题就开始反向调试，尝试看X是从哪来的，会不会有问题。"><meta name="keywords" content="X-prop"><meta property="og:type" content="article"><meta property="og:title" content="What is inside of an X?"><meta property="og:url" content="http:&#x2F;&#x2F;winter-leaf.github.io&#x2F;What-is-inside-of-an-X&#x2F;index.html"><meta property="og:site_name" content="Leaf in winter"><meta property="og:description" content="很多人在做Xprop仿真的时候大都是对仿真器加入一个选项，然后就跑仿真模型了，有了问题就开始反向调试，尝试看X是从哪来的，会不会有问题。"><meta property="og:locale" content="en"><meta property="og:image" content="http:&#x2F;&#x2F;winter-leaf.github.io&#x2F;What-is-inside-of-an-X&#x2F;nand-if.png"><meta property="og:image" content="http:&#x2F;&#x2F;winter-leaf.github.io&#x2F;What-is-inside-of-an-X&#x2F;nor-if.png"><meta property="og:image" content="http:&#x2F;&#x2F;winter-leaf.github.io&#x2F;What-is-inside-of-an-X&#x2F;mux-if.png"><meta property="og:image" content="http:&#x2F;&#x2F;winter-leaf.github.io&#x2F;What-is-inside-of-an-X&#x2F;x-lockup.png"><meta property="og:updated_time" content="2020-05-16T16:53:46.927Z"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http:&#x2F;&#x2F;winter-leaf.github.io&#x2F;What-is-inside-of-an-X&#x2F;nand-if.png"><link rel="canonical" href="http://winter-leaf.github.io/What-is-inside-of-an-X/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>What is inside of an X? | Leaf in winter</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Leaf in winter</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Do you see the wind?</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> Archives</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="http://winter-leaf.github.io/What-is-inside-of-an-X/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="winter leaf"><meta itemprop="description" content="Batman, if you don't believe it then superman"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Leaf in winter"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> What is inside of an X?</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-05-16 11:34:20" itemprop="dateCreated datePublished" datetime="2020-05-16T11:34:20+08:00">2020-05-16</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2020-05-17 00:53:46" itemprop="dateModified" datetime="2020-05-17T00:53:46+08:00">2020-05-17</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/summary/" itemprop="url" rel="index"><span itemprop="name">summary</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>很多人在做Xprop仿真的时候大都是对仿真器加入一个选项，然后就跑仿真模型了，有了问题就开始反向调试，尝试看X是从哪来的，会不会有问题。</p><a id="more"></a><p>但不会细想里面到底发生了什么，而X的出现情况又是什么。最近察看了一些资料，把启发记录一下。<br>这里写的启发和总结主要是参考一片文章, [1]Stuart, “I’m Still In Love With My X”, Design and Verification Conference, 2013.</p><h1 id="1-Data-Type"><a href="#1-Data-Type" class="headerlink" title="1. Data Type"></a>1. Data Type</h1><p>首先要说的是可能多数人会有的一个误区, verilog/systemverilog不只有数据类型，还有变量类型和端口类型。<br>一般的代码中习惯的都只定义“logic a;”，但实际上数据类型logic只是表征了一个4态的数值集合(0,1,X,Z)，同理的还有bit(0,1)。但它并不表示a这个符号的语义。<br>符号还有一个变量类型的属性: var, reg, integer, time. 用以表示它到底是变量，数组，时间等等。所以，具体的应该是”var logic a;”.<br>一般若是省略了变量类型，编译器会自行地根据情况设置一个上去。</p><h1 id="2-what-is-X-where-is-it-from"><a href="#2-what-is-X-where-is-it-from" class="headerlink" title="2. what is X? where is it from?"></a>2. what is X? where is it from?</h1><p>X是4态数值集合中的一个，用于表示逻辑值不明确的情况。<br>一般X出现的情况有以下几种:</p><ol><li>没对信号初始化</li><li>没连接的端口信号</li><li>同一个信号，多个驱动源</li><li>低功耗仿真时的上电、掉电</li><li>数组访问时索引超界</li><li>不满足建立时间和保持时间</li><li>设计者自己赋值的X</li></ol><p>这里面值得注意的时情况4。在掉电上电仿真的时候，信号会在仿真运行过程中被强制设定为X，而且这个X不会自己在上电后仿真中自己调整，会一直保持X值直到信号在接下来的仿真过程中被重新赋值。这就会造成一个X的锁存现象。<br>这个现象是仿真过程自己设定的，与真实半导体中的情况不同。半导体上电后取决于模式设定情况，会有一个确定值0或1, 但仿真在这里没法表征它，只能带着X这个值在重新上电后再进行一段时间的仿真。</p><h1 id="3-How-do-we-handle-X"><a href="#3-How-do-we-handle-X" class="headerlink" title="3. How do we handle X?"></a>3. How do we handle X?</h1><p>X主要造成的问题是: 仿真模型与真实硅上情况不一样，或者说仿真模型没办法正确地模拟硅上场景。因为真实的半导体会在0,1中选择一个值来运行，而不会模棱两可地找一个中间值。<br>对于X的处理一般有两种情况:</p><ul><li>X-optimism, 指仿真器会在X值导致仿真结果不确定的时候，把有关X的仿真结果换成一个明确的值(0或1)。</li><li>X-pessimism, 指仿真器会在X值导致仿真结果不确定的时候，把有关X的仿真结果一律看成X。</li></ul><h2 id="3-1-X-optimism"><a href="#3-1-X-optimism" class="headerlink" title="3.1 X-optimism"></a>3.1 X-optimism</h2><p>X-optimism在大多数仿真情况下，都可以正确地模拟硅上情况。比如与门，b = x AND a，无论a是0或1, b的模拟值都与硅上结果一样，尤其是在a=0时，b=0。如果是使用x-pessimism，这里b=x。<br>但X-optimism也有无法正确模拟的情况。</p><h3 id="3-1-1-if-else-statement"><a href="#3-1-1-if-else-statement" class="headerlink" title="3.1.1 if-else statement"></a>3.1.1 if-else statement</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cond) <span class="keyword">begin</span></span><br><span class="line">  y = a;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">  y = b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果cond=x, systemverilog在默认情况下会选择else这条路线。但真正半导体会把X看做0或1, 两条路线都可以执行。这里x-optimism不能保证100%正确模拟。<br>具体的正确与否要看最终综合出来的门级电路模型。常见的if-else有三种综合结果:</p><ul><li><p>NAND based<br><img src="nand-if.png" alt="nand-if"></p></li><li><p>NOR based<br><img src="nor-if.png" alt="nor-if"></p></li><li><p>MUX based<br><img src="mux-if.png" alt="mux-if"></p></li></ul><p>把cond=x, {a,b}=00,01,10,11的情况代入一下可以发现，NAND和NOR的结果和仿真模型的结果都不一样，而MUX的结果是与仿真模型一致的。所以，以MUX工艺库进行综合，可以匹配仿真模型的结果，NAND和NOR都做不到。</p><p>其实这里有一点小思考，个人觉得把if-else单纯地归结为x-optimitic有些笼统。这里仿真器会只选择else分支是因为分支情况省略，而不是因为X被当做了0. if-else语句是可以识别X和Z的，如果明确地把所有分支列出来，</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cond) <span class="keyword">begin</span></span><br><span class="line">  y = a;</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!cond) <span class="keyword">begin</span></span><br><span class="line">  y = b;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cond===<span class="number">1'bx</span>) <span class="keyword">begin</span></span><br><span class="line">  y = <span class="number">1'bx</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">  y = <span class="number">1'bz</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>if-else还是可以正确地选择。分支的省略造成了0,x,z这些非1值都走了else分支。</p><h3 id="3-1-2-case-statement"><a href="#3-1-2-case-statement" class="headerlink" title="3.1.2 case statement"></a>3.1.2 case statement</h3><p>case statement有如下几个问题:</p><ul><li><p>有default分支<br>考虑下面一个例子,</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span>(cond)</span><br><span class="line">  <span class="number">1'b0</span>: y = a;</span><br><span class="line">  <span class="number">1'b1</span>: y = b;</span><br><span class="line">  <span class="keyword">default</span>: y = <span class="number">1'bx</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>cond，a，b，y都是一位的变量。cond=x, 则y变成x。<br>而在实硅上，cond永远不会是x，即default分支永远不会被执行，y最终会是a或b，而不是x。假如极端情况下，a=b=1，那么y在实硅上只有一个值1. 但仿真结果则表示y可以是x，即任何值。<br>所以这里就有区别，仿真模型不能模拟真实情况。</p></li><li><p>没有default分支<br>在case语句中，如果不定义default分支的话，相当于没有执行case语句。如果case分支像上面的例子一样是负责赋值工作，那么就会保持原来的值，在时序电路中就是上一个周期的值。<br>这显然也是不对的，在实硅上y肯定会被更新到a或b的值而不会是原值(如果不考虑a，b恰好等于y的原值)。<br>仿真模型还是不能模拟真实情况。</p></li></ul><blockquote><p>从上面可以看出，无论有没有default分支，仿真模型都没办法正确地模拟实硅情况。</p></blockquote><ul><li>case的多种形式以及双向通配性<br>case语句的x双向性表现在条件和选项里。以上面的例子而言，条件指cond这一表达式，选项指1’b0:, 1’b1:这些具体的分支罗列情况。<br>x，z可以出现在cond里，也可以出现在选项里，比如1’bx:，即两个地方都能有x.<br>双向通配指如果cond出现x或z，那么cond可以去匹配选项里的0,1,x,z，同时选项里出现了x或z，那么选项也可以去匹配cond中的0,1,x,z。</li></ul><p>case的形式有4种:</p><ol><li>case(cond)</li><li>casez(cond)</li><li>casex(cond)</li><li>case(cond) inside</li></ol><p>对于情况1, 逻辑值0, 1, x，z都会被case语句独立识别。由于独立识别，这里也没有什么通配的问题，但无疑会降低仿真模型的灵活性。<br>对于情况2, 逻辑值z会被当做双向通配符，’?’符号在这里相当于z。<br>对于情况3, 逻辑值x，z会被当做双向通配符，’?’符号在这里相当于下x，z。<br>对于情况4, 逻辑值x，z会被当做 |单向| 通配符，这是不同的地方，只有选项里的x，z可以单向匹配cond中的0, 1, x, z。cond中的x，z会独立识别。’?’符号在这里相当于x，z。</p><p>双向通配性都是x-optimistic，会造成不同的匹配情况，很多无法正确的模拟实硅情况。相比之下case(cond) inside的单向匹配稍好，但仍然无法正确模拟。<br>看一个例子，</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span>(cond) <span class="keyword">inside</span></span><br><span class="line">  <span class="number">3'b1xx</span>: y = a;</span><br><span class="line">  <span class="number">3'b0x1</span>: y = b;</span><br><span class="line">  <span class="number">3'b0x0</span>: y = c;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure><p>假如cond=3’bx01, 由于选项的顺序和通配性，第一个选项3’b1xx会被选择，y=a. 但在实硅上，x有可能是0, 那么cond=3’b001, 第一个选项是不匹配的，而第二个选项会被匹配。<br>这还是无法正确地模拟。</p><blockquote><p>从上面可以看出，case的通配性没办法正确地模拟实硅情况。</p></blockquote><h3 id="3-1-3-operators"><a href="#3-1-3-operators" class="headerlink" title="3.1.3 operators"></a>3.1.3 operators</h3><p>x-optimistic的运算符有:</p><ul><li>bitwise: AND(&amp;), OR(|)</li><li>unary: AND(&amp;), NAND(<del>&amp;), OR(|), NOR(</del>|)</li><li>logical: AND(&amp;&amp;), OR(||), IMPLICATION(-&gt;), EQUIVALENCE(&lt;-&gt;)<br>EQUIVALENCE(&lt;-&gt;)比较少用，表示双向推导，相当于 ((expr1 -&gt; expr2) &amp;&amp; (expr2 -&gt; expr1)).</li></ul><p>这些运算符会给出一个在操作符是x时的optimistic结果。</p><h3 id="3-1-4-unconnected-port"><a href="#3-1-4-unconnected-port" class="headerlink" title="3.1.4 unconnected port"></a>3.1.4 unconnected port</h3><p>对于未连接的端口信号，仿真模型会给于一个确定的指0或1进行仿真。但实硅上有可能与仿真时赋予的值不一样，导致模拟错误。</p><h3 id="3-1-5-sensitivity-edge"><a href="#3-1-5-sensitivity-edge" class="headerlink" title="3.1.5 sensitivity edge"></a>3.1.5 sensitivity edge</h3><p>SV中，对变化沿采取x-optmism机制。<br>0-&gt;1, 0-&gt;Z, Z-&gt;1, 0-&gt;X, X-&gt;1会被认为是posedge。<br>1-&gt;0, 1-&gt;Z, Z-&gt;0,1-&gt;X, X-&gt;0会被认为是negedge。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">  y &lt;= y+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面的代码中，如果clk出现了x-&gt;1，那么y会增加。但实硅上x可能是1,那么就没有上升沿，y就不会增加。x-optimistic的机制造成模拟错误。</p><h2 id="3-2-X-pessimism"><a href="#3-2-X-pessimism" class="headerlink" title="3.2 X-pessimism"></a>3.2 X-pessimism</h2><p>x-pessimism机制会在X值导致仿真结果不确定的时候，把有关X的仿真结果一律看成X。这种机制不会像x-optimism那样在某些情况下通过强制赋值导致非真实模拟。<br>但也会大大增加x的出现次数，可能导致x的泛滥，甚至将x值从产生的地方一路传的很深，从而使得调试更加困难。<br>x-pessimism机制也会造成不必要的x添加。比如，x AND 0, 结果只可能是0, 包括实硅的情况。但x-pessimism机制会输出x。</p><h3 id="3-2-1-X-lock-up"><a href="#3-2-1-X-lock-up" class="headerlink" title="3.2.1 X lock-up"></a>3.2.1 X lock-up</h3><p>x-pessimism会造成X值的死锁现象。当触发器的输出被x-pessimism机制赋值为x后，一旦输出x会将x值反馈给输入，则会出现从输入到输出的一个死循环，如下图。<br><img src="x-lockup.png" alt="x-lockup"></p><p>由于输入侧的非门也采用x-pessimism机制，导致x的死锁。在实硅上，x会变成0或1, 不会出现死锁。<br>这里x-pessimism机制会造成错误模拟。</p><h3 id="3-2-2-operators"><a href="#3-2-2-operators" class="headerlink" title="3.2.2 operators"></a>3.2.2 operators</h3><p>x-pessimistic的运算符有:</p><ul><li>bitwise: INVERT(<del>), XOR(^), XNOR(</del>^)</li><li>unary: XOR(^), XNOR(~^)</li><li>logical: NOT(!)</li><li>arithmetic: +, -, *, / 等等</li><li>relational: &lt;, &gt;, &lt;=, &gt;= 等等</li><li>shift: &lt;&lt;, &gt;&gt;</li></ul><p>由于算数运算符是x-pessimistic，像下面这个例子，即使真实情况乘法结果为0, 但仿真模型还是会返回x，同时比较运算符也是x-pessimistic，造成比较结果也是x。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] a = <span class="number">4'b010x</span>;</span><br><span class="line"></span><br><span class="line">b = a * <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(b &gt; <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里有一个技巧，由于XOR(^)是x-pessimistic，我们可以用来检测多位信号是否任意位是0, 如下:</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] a = <span class="number">4</span>'<span class="number">01</span>x0;</span><br><span class="line"><span class="keyword">if</span>(^a === <span class="number">1'bx</span>) <span class="keyword">begin</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="3-1-5-indexing-with-X"><a href="#3-1-5-indexing-with-X" class="headerlink" title="3.1.5 indexing with X"></a>3.1.5 indexing with X</h3><p>看下面一例子，</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] addr = <span class="number">4'b000x</span>;</span><br><span class="line">data = mem[addr];</span><br></pre></td></tr></table></figure><p>data的值是什么？<br>如果是x-pessimistic的机制，由于地址索引中有x，仿真模型会认为没有索引成功，data的值会是x。<br>这显然和实硅的情况不同，实硅上data肯定会有一个赋值。</p><h1 id="4-Why-not-only-use-2-state-data-type"><a href="#4-Why-not-only-use-2-state-data-type" class="headerlink" title="4. Why not only use 2-state data type?"></a>4. Why not only use 2-state data type?</h1><p>只用2态的数据类型确实会简化x的分析，但弊大于利。原因如下:</p><ol><li>某些情况下，会无法反应设计问题，设计隐患会被隐藏。比如同一变量的多源驱动，x值可以反应问题，但用了2态类型，结果就不再是x，而是0或1，仿真的时候也不会报错。</li><li>初始化问题。如果用2态类型，那么未初始化的信号也会被仿真模型赋予一个确定的初始值。而这个值并不一定能反应实硅的真实情况。</li></ol><h1 id="5-Current-maybe-imperfect-solutions-for-X-detection"><a href="#5-Current-maybe-imperfect-solutions-for-X-detection" class="headerlink" title="5. Current (maybe imperfect) solutions for X detection"></a>5. Current (maybe imperfect) solutions for X detection</h1><p>从上面的叙述来看，很难找到一个比较完美的方法来把所有的情况都能正确地模拟出来。<br>一些EDA公司会提供一些针对于x值的仿真模型，比如synopsys的VCS x-prop。x-prop的机制是尽量在仿真模型中找一个optimistic和pessimistic的平衡。它会尽量在x值不确定时，去尝试各个x可能的取值分支，并把分支得到的临时结果记录下来，最终把所有临时结果整合在一起，得到最终结果。<br>这里的整合方法一般有两种:</p><ol><li><p>T merge<br>T merge会在各个输入不同，或各个输入中有x,z的时，返回x。如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T_merge(a, b):</span><br><span class="line">  <span class="keyword">if</span>(a != b <span class="keyword">or</span></span><br><span class="line">     a == <span class="number">1</span><span class="string">'bx or a == 1'</span>bz <span class="keyword">or</span></span><br><span class="line">	 b == <span class="number">1</span><span class="string">'bx or b == 1'</span>bz):</span><br><span class="line">    <span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure></li><li><p>X merge<br>X merge会在任意情况下返回x。如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_merge(a, b):</span><br><span class="line">  <span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure></li></ol><p>相比之下，T merge能更加正确地模拟实际情况。X merge更pessimistic，但X merge也有其作用，比如为了检测一个原则上不应该出现x的设计是否会出现x，就可以用X merge。</p><h1 id="6-A-suggestion-in-article"><a href="#6-A-suggestion-in-article" class="headerlink" title="6. A suggestion in article"></a>6. A suggestion in article</h1><p>文章[1]中给出了一个建议，就是利用断言，在每个有局部信号输入的时候，都加上断言来检测输入是否为x。这样可以在第一时间在x的出现地报告x。同时断言还有一个好处，就是不会被综合，x的断言检测只会在仿真时作用。<br>但一个潜在问题就是，这可能会导致这种断言重复写的到处都是，有大量重复性工作，且这种做法也取决于个人习惯。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>Post author:</strong> winter leaf</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="http://winter-leaf.github.io/What-is-inside-of-an-X/" title="What is inside of an X?">http://winter-leaf.github.io/What-is-inside-of-an-X/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally. Please indicate the source when reproduce.</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/X-prop/" rel="tag"># X-prop</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/Design-Pattern-Strategy-Pattern/" rel="next" title="Design Pattern - Strategy Pattern"><i class="fa fa-chevron-left"></i> Design Pattern - Strategy Pattern</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/%E5%B0%8F%E8%AE%AErandomize/" rel="prev" title="小议randomize">小议randomize<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Data-Type"><span class="nav-text">1. Data Type</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-what-is-X-where-is-it-from"><span class="nav-text">2. what is X? where is it from?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-How-do-we-handle-X"><span class="nav-text">3. How do we handle X?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-X-optimism"><span class="nav-text">3.1 X-optimism</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-if-else-statement"><span class="nav-text">3.1.1 if-else statement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-case-statement"><span class="nav-text">3.1.2 case statement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-operators"><span class="nav-text">3.1.3 operators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-unconnected-port"><span class="nav-text">3.1.4 unconnected port</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5-sensitivity-edge"><span class="nav-text">3.1.5 sensitivity edge</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-X-pessimism"><span class="nav-text">3.2 X-pessimism</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-X-lock-up"><span class="nav-text">3.2.1 X lock-up</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-operators"><span class="nav-text">3.2.2 operators</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5-indexing-with-X"><span class="nav-text">3.1.5 indexing with X</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Why-not-only-use-2-state-data-type"><span class="nav-text">4. Why not only use 2-state data type?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Current-maybe-imperfect-solutions-for-X-detection"><span class="nav-text">5. Current (maybe imperfect) solutions for X detection</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-A-suggestion-in-article"><span class="nav-text">6. A suggestion in article</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="winter leaf" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">winter leaf</p><div class="site-description" itemprop="description">Batman, if you don't believe it then superman</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <span class="site-state-item-count">9</span> <span class="site-state-item-name">categories</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">15</span> <span class="site-state-item-name">tags</span></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-gamepad"></i></span> <span class="author" itemprop="copyrightHolder">winter leaf</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script></body></html>