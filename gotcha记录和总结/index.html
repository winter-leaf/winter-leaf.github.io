<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/ico32x32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/ico16x16.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Liu Jian Mao Cao:300,300italic,400,400italic,700,700italic|Shadows Into Light:300,300italic,400,400italic,700,700italic|Yeon Sung:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"7.5.0",exturl:!1,sidebar:{position:"left",width:300,display:"hide",offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"Copy",copy_success:"Copied",copy_failure:"Copy failed"},sidebarPadding:40}</script><meta name="description" content="记录和总结一下见到的个人觉得有启发的gotcha。"><meta name="keywords" content="gotcha"><meta property="og:type" content="article"><meta property="og:title" content="gotcha记录和总结"><meta property="og:url" content="http:&#x2F;&#x2F;winter-leaf.github.io&#x2F;gotcha%E8%AE%B0%E5%BD%95%E5%92%8C%E6%80%BB%E7%BB%93&#x2F;index.html"><meta property="og:site_name" content="Leaf in winter"><meta property="og:description" content="记录和总结一下见到的个人觉得有启发的gotcha。"><meta property="og:locale" content="en"><meta property="og:updated_time" content="2021-05-29T06:30:20.866Z"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://winter-leaf.github.io/gotcha%E8%AE%B0%E5%BD%95%E5%92%8C%E6%80%BB%E7%BB%93/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>gotcha记录和总结 | Leaf in winter</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Leaf in winter</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Do you see the wind?</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> Archives</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> Search</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Searching..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="http://winter-leaf.github.io/gotcha%E8%AE%B0%E5%BD%95%E5%92%8C%E6%80%BB%E7%BB%93/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpeg"><meta itemprop="name" content="winter leaf"><meta itemprop="description" content="Batman, if you don't believe it then superman"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Leaf in winter"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> gotcha记录和总结</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-07-16 19:46:27" itemprop="dateCreated datePublished" datetime="2020-07-16T19:46:27+08:00">2020-07-16</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">Edited on</span> <time title="Modified: 2021-05-29 14:30:20" itemprop="dateModified" datetime="2021-05-29T14:30:20+08:00">2021-05-29</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SystemVerilog/" itemprop="url" rel="index"><span itemprop="name">SystemVerilog</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>记录和总结一下见到的个人觉得有启发的gotcha。</p><a id="more"></a><h1 id="1-关于bit的迷思"><a href="#1-关于bit的迷思" class="headerlink" title="1.关于bit的迷思"></a>1.关于bit的迷思</h1><h2 id="1-1-位省略"><a href="#1-1-位省略" class="headerlink" title="1.1 位省略"></a>1.1 位省略</h2><p>先来看一个问题, 12’shFF和12’(8’shFF)的值一样吗？<br>既然这么问了，结果肯定是不一样。12’shFF的二进制结果是 000011111111，12’(8’shFF)的二进制结果是111111111111。<br>进一步想，’shFF的值是什么？<br>‘shFF的二进制结果是0…00011111111。<br>这里到底发生了什么？</p><p>要明白这个问题，要先明白数值的字符表示是什么样的。<br>数值表示有如下格式:<br>[size]’[s]</p><base><value>，其中符号标志[size]及[s]可省略，[s]省略则表示为无符号数。<br>[size]表示最终这个数值表示的二进制位数。如果省略，则至少表示32位，这也是为什么上面的’shFF没有具体给出的0的个数。<p></p><p>在[size]’[s]</p><base><value>表示形式下，任何数值都是以无符号二进制表示的。base_value决定了的二进制数值大小。<br>负号”-”表示是否将二进制转换为补码形式。’s’表示编译器最终看待数值的方式，是以无符号数看待还是以有符号数看待。<p></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$display</span>(<span class="string">"%b"</span>, -<span class="number">'d12</span>);  <span class="comment">// 11111111111111111111111111110100</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">"%d"</span>, -<span class="number">'d12</span>);  <span class="comment">// 4294967284</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">"%b"</span>, -'sd12); <span class="comment">// 11111111111111111111111111110100</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">"%d"</span>, -'sd12); <span class="comment">// -12</span></span><br></pre></td></tr></table></figure><p>那么12’shFF就很好理解了，最终结果肯定是一个12位的有符号数。但是只给定了低8位数值，没有给定高4位，那高四位的值应该是什么？<br>这就涉及到位省略的问题。在verilog/systemverilog中，在给定整体位数且数值位数比整体位数低的情况下，高位不是x或z时，默认补0，高位是x或z时，默认补x或z。所以12’shFF中没有给定的高四位就是0.</p><h2 id="1-2-位扩展"><a href="#1-2-位扩展" class="headerlink" title="1.2 位扩展"></a>1.2 位扩展</h2><p>那为什么12’(8’shFF)的结果是111111111111？<br>这里涉及到位扩展的问题。8’shFF不涉及到任何位省略的情况，且是符号数，那么结果就是十进制的-1。关键在于之后12’()的扩展。<br>扩展是根据最高位定的。8’shFF的最高位是1，所以扩展后就是111111111111。</p><p>再想一个小问题, -12’shFF的结果是什么？<br>-12’shFF其实可以分成(-)和(12’shFF)两部分。那结果就很显而易见了是十进制的-255。</p><p>上面解释了位扩展，那么赋值的时候扩展是什么样的？比如 logic signed [7:0] a = 4’hF ?<br>赋值时的扩展遵循这样一个原则: 最终扩展位数根据左侧变量位数而定，扩展位的值根据右侧原变量最高位而定。<br>根据此原则，上面例子的最终结果就是a = 8’(4’hF) -&gt; 00001111。</p><h2 id="1-3-变量运算"><a href="#1-3-变量运算" class="headerlink" title="1.3 变量运算"></a>1.3 变量运算</h2><p>如果是变量运算呢？形如 logic[3:0] a = 2’sh3 + 2’h2?<br>扩展位数的问题上面已经解释过了，仍然是看左侧的位数。主要问题是(signed number + unsigned number)的结果到底是个signed还是unsigned？<br>无符号数/有符号数的运算原则是(u=无符号，s=有符号，‘→’表示结果): u+u→u, s+s→s, u+s→u。<br>那么显然例子中a最终应该得到一个从右侧得来的无符号值，具体过程是这样的:</p><ol><li>检测到右侧是u+s，那么把所有的值都当做无符号数运算</li><li>检测到左侧是4位宽度，对右侧进行位扩展4’(2’h3) + 4’(2’h2)</li><li>计算得到临时无符号数结果4’h3+4’h2=4’h5</li><li>由于最终是4位且给定数值是3位的h5，那么出现位省略的情况，直接高位补0，所以最终结果是a = 0101</li></ol><p>这里提一个关于变量运算的小插曲</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">logic signed [3:0] a,b;</span><br><span class="line">logic signed       cin;</span><br><span class="line"></span><br><span class="line">a = 3;</span><br><span class="line">b = 4;</span><br><span class="line">cin = 1;</span><br><span class="line">a + b + cin = ?</span><br></pre></td></tr></table></figure><p>如果查看结果的话会发现a + b + cin = 6, 而不是预想中的8。<br>这是由于cin的符号性，由于cin是符号数，所以值1就代表了运算中十进制的-1，即结果是a+b+(-1)。<br>拆开来看，整个右侧都是符号数所以会对cin进行符号位扩展得到4’b1111，还是十进制的-1.<br>要想解决，就必须把-1变成+1，即更换符号位，但是cin只有一位，没办法再从自身改变。那么就只能手动补上一个符号位{1’b0, cin}。</p><h2 id="1-4-位选取"><a href="#1-4-位选取" class="headerlink" title="1.4 位选取"></a>1.4 位选取</h2><p>位选取运算的结果永远是无符号的，即使从有符号数中位选也还是得到无符号数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logic signed[3:0] a;</span><br><span class="line">logic signed[4:0] b;</span><br><span class="line">a = -1;</span><br><span class="line">b = a[3:0];</span><br></pre></td></tr></table></figure><p>即使我们没有对a做任何改变，但位选取运算使得a[3:0]得到一个符号数。最终b的结果不是-1，而是01111即十进制15。</p><h1 id="2-异步条件优先级"><a href="#2-异步条件优先级" class="headerlink" title="2.异步条件优先级"></a>2.异步条件优先级</h1><p>看一个用于仿真测试的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">always_ff(posedge clk, negedge rst_n, negedge set_n) begin</span><br><span class="line">  if(!rst_n) begin</span><br><span class="line">    q &lt;= 1’b0;</span><br><span class="line">  end else if (!set_n) begin</span><br><span class="line">    q &lt;= 1’b1;</span><br><span class="line">  end else begin</span><br><span class="line">    q &lt;= d;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>仿真模型的逻辑意图很明显，实现异步的复位和置位工作。但这里面有一个坑，那就是它其实还含有一个优先级的仲裁机制。在复位期间如果置位也随后出现，那么复位会把置位的分支给取代掉。这样一来即使复位信号被取消且置位信号还是有效，由于没有触发事件，置位分支仍然不会马上被执行。直到有下一个时钟沿，置位分支才会被执行。</p><p>这里本质上我们要模拟的是一个latch，这个latch以rst_n和set_n作为敏感信号进行电平触发。<br>但从综合器的角度来看，latch和时钟沿数据更新的always_ff是不匹配的。而且在综合后我们想要做的也是时钟沿触发而不是电平触发，也就是说，等到下一个时钟沿再去置位是合理的结果。</p><p>但仿真模拟时，我们却需要latch来达到目的。</p><p>这里有两个方法:<br>一是压根就别在复位的期间进行置位，因为这本身就不符合正常用法。<br>二是如果真要在复位的期间进行置位，那么可以用下面的例子，但要区分这只用于仿真过程，而不用于综合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">`ifdef only_for_simulation</span><br><span class="line">always @* begin</span><br><span class="line">  if(rst_n &amp;&amp; !set_n) begin</span><br><span class="line">    force q = 1;</span><br><span class="line">  end else begin</span><br><span class="line">    release q;</span><br><span class="line">  end  </span><br><span class="line">end</span><br><span class="line">`endif</span><br><span class="line"></span><br><span class="line">always_ff(posedge clk, negedge rst_n, negedge set_n) begin</span><br><span class="line">  if(!rst_n) begin</span><br><span class="line">    q &lt;= 1’b0;</span><br><span class="line">  end else if (!set_n) begin</span><br><span class="line">    q &lt;= 1’b1;</span><br><span class="line">  end else begin</span><br><span class="line">    q &lt;= d;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="3-enum默认初始值"><a href="#3-enum默认初始值" class="headerlink" title="3.enum默认初始值"></a>3.enum默认初始值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;A, B, C&#125; cur_st, nxt_st;</span><br><span class="line"></span><br><span class="line">always_ff @(posedge clk) begin</span><br><span class="line">  if(!rst_n) begin</span><br><span class="line">    cur_st &lt;= A;</span><br><span class="line">  end else begin</span><br><span class="line">    cur_st &lt;= nxt_st;</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">always @(cur_st) begin</span><br><span class="line">  case(cur_st) inside</span><br><span class="line">    A: nxt_st = B;</span><br><span class="line">    B: nxt_st = C;</span><br><span class="line">    C: nxt_st = A;</span><br><span class="line">  endcase</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这个例子中cur_st会永远的卡在A值上。<br>原因是enum的初始化问题。在不指定enum类型的情况下，enum默认会初始化到0，而0正好是列表中的第一个值。在例子中就是A，那么即使碰到了复位，值还是变到A，相当于没变化，那么后续的状态更新也就不会被触发。</p><p>要解决这个问题有三个方法:</p><ol><li>推荐方法，不要用always @(xx)的latch风格，而是用always_comb，always_comb会在仿真最开始的时候自动的激活一次。</li><li>给enum加上类型，比如enum logic[1:0] {A,B,C}。类型的添加能使默认初始化值变到X。</li><li>手动添加非零的值比如enum {A=1,B=2,C=3}。</li></ol><h1 id="4-missing-event-trigger"><a href="#4-missing-event-trigger" class="headerlink" title="4.missing event trigger"></a>4.missing event trigger</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">initial begin</span><br><span class="line">  -&gt;evt;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">always @(evt) begin</span><br><span class="line">  q &lt;= 0;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>上面的这段always代码有可能永远不会执行，原因是evt的触发在@(evt)之前，即在等待之前就触发了，从而到时错过event。<br>有两种方法可以解决:</p><ol><li>从触发角度解决，用#0-&gt;evt或者-&gt;&gt;evt操作符来让触发延后一个delta cycle</li><li>从等待角度解决，用wait(evt.triggered)</li></ol><h1 id="5-semaphore等待机制"><a href="#5-semaphore等待机制" class="headerlink" title="5.semaphore等待机制"></a>5.semaphore等待机制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore s = new(3);</span><br><span class="line"></span><br><span class="line">initial begin</span><br><span class="line">  s.get(1); // A</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">initial begin</span><br><span class="line">  s.get(1); // B</span><br><span class="line">  #10ns;</span><br><span class="line">  s.get(1); // C</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">initial begin</span><br><span class="line">  #5ns;</span><br><span class="line">  s.get(2); // D</span><br><span class="line">  s.get(1); // E</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>上面这段代码的关键点是理解C和D。在步骤A和B中，它们同时在0时刻各自取得一个token，在5ns后D步骤试图取得两个token但没有足够的数量。所以D会等待直到token个数满足两个。重点是步骤C和E，C在另一个线程中且在时间上晚于D执行，但却可以先于D结束，因为C可以成功取得一个token。而E和D在同一线程，即使在5ns时有足够的token也不能先于D执行。</p><p>结论，同一线程中semaphore.get()的顺序执行，不同线程中的semaphore.get()独立执行且共享一个semaphore pool。</p><h1 id="6-wire-reg-logic"><a href="#6-wire-reg-logic" class="headerlink" title="6. wire,reg,logic"></a>6. wire,reg,logic</h1><p>reg和logic一样，只不过在systemverilog中reg有了相应的数据类型logic.<br>wire是net类型不能储值，而reg/logic可以。<br>wire可以有多驱动源，而reg/logic不可以。</p><h1 id="7-消失的函数返回值"><a href="#7-消失的函数返回值" class="headerlink" title="7.消失的函数返回值"></a>7.消失的函数返回值</h1><p>在verilog/systemverilog中，函数定义省略返回值时，默认返回值是logic。也就是说所有的返回值最终只会有LSB。<br>例如下面的例子，返回值是1而不是7.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo();</span><br><span class="line">  int a;</span><br><span class="line">  a = 7;</span><br><span class="line">  return a;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><h1 id="8-带默认值的形参只能放在ref类型形参前吗？"><a href="#8-带默认值的形参只能放在ref类型形参前吗？" class="headerlink" title="8. 带默认值的形参只能放在ref类型形参前吗？"></a>8. 带默认值的形参只能放在ref类型形参前吗？</h1><p>如果这样定义和使用函数就会报错:<br>function void foo(ref int a, int b=0);</p><p>int x;<br>foo(x);</p><p>error message:</p><blockquote><p>Illegal connection to the ref port ‘b’ of function/task ‘foo’,formal<br>argument should have same type as actual argument.</p></blockquote><p>为什么？难道函数还对形参位置敏感？<br>这其实是形参端口类型的问题。共有四个形参端口类型input, output, inout, ref。这四个类型都可以进行默认赋值。但在SV中默认省略端口类型时，省略类型与前一个相同，若没前一个则默认为input。<br>四个类型中只有input可以不进行实参传递，其他的类型本质上具有连接性，使用时必须进行实参传递。<br>那么上面的例子很显然是错误地认为b会当做input类型而省略实参传递。<br>解决方法: 把b也显式地进行赋值，foo(x, y);</p><h1 id="9-消失的延时赋值语句"><a href="#9-消失的延时赋值语句" class="headerlink" title="9.消失的延时赋值语句"></a>9.消失的延时赋值语句</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">initial begin</span><br><span class="line">  clk &lt;= 0;</span><br><span class="line">  forever #5 clk = ~clk;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">assign #3 a = clk;</span><br><span class="line">assign #6 b = clk;</span><br></pre></td></tr></table></figure><p>运行上面的代码时会发现b永远不会变。为什么会这样？<br>要理解这个就要先明白两个概念，惯性延时和传输延时。<br>传输延时就是指先采样一个值，再经过特定的延时时间将其输出。<br>惯性延时就是指先采样一个值，并指定一个惯性时段，在惯性时段内如果输入再次发生变化则忽略前一个采样，采用新采样值，并重新计算惯性时段，直到某一个惯性时段内没有多次变化后结束后再将其输出。换句话说，给定一个时段，如果时段内出现两个值，取后面那个，并重新计时。这一般是为了滤除目的值之前的glitch。</p><p>例子中的assign #3和assign #6就是惯性延时。由于#6的惯性时段长于#5，在惯性时段内clk可以变换两次，那么取消#5前的采样并重新计时，再计时又是#6，又会碰到变换两次的clk，一直延续下去。b永远不被赋值。</p><p>解决办法就是换成传输延时:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">always @(clk) begin</span><br><span class="line">  b &lt;= #6 clk;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="10-任务被自己侵犯了"><a href="#10-任务被自己侵犯了" class="headerlink" title="10.任务被自己侵犯了"></a>10.任务被自己侵犯了</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">module tb;</span><br><span class="line">  task foo(string name, int n);</span><br><span class="line">    repeat(n) begin</span><br><span class="line">      #10ns;</span><br><span class="line">      $display(&quot;time = %0dns, name = %0s&quot;, $time, name);</span><br><span class="line">    end</span><br><span class="line">  endtask</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  initial begin</span><br><span class="line">    fork</span><br><span class="line">      begin</span><br><span class="line">        foo(&quot;kkk&quot;, 6);</span><br><span class="line">      end</span><br><span class="line">      begin</span><br><span class="line">        #25ns;</span><br><span class="line">        foo(&quot;qqq&quot;, 6);</span><br><span class="line">      end</span><br><span class="line">    join</span><br><span class="line">  end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>如果执行上面这段代码会有如下输出:</p><blockquote><p>time = 10ns, name = kkk<br>time = 20ns, name = kkk<br>time = 30ns, name = qqq<br>time = 35ns, name = qqq<br>time = 40ns, name = qqq<br>time = 45ns, name = qqq<br>time = 50ns, name = qqq<br>time = 55ns, name = qqq<br>time = 60ns, name = qqq<br>time = 65ns, name = qqq<br>time = 75ns, name = qqq<br>time = 85ns, name = qqq</p></blockquote><p>结果表示从第二个线程真正开始运行任务后，第一个线程的任务的内容竟然被第二个线程任务覆盖了。这怎么回事？</p><p>原因是因为任务的定义是static静态的。如果定义成task automatic或者直接放在class里就能正常输出。<br>static的任务会共享一个函数/任务地址空间。上面的代码相当于对一个正在执行的任务动态改变了形参。<br>第一个线程会在一开始采样形参n的值，执行6次循环，每次重新读取形参name的值。<br>第二个线程会在25ns后采样形参n的值，也执行6次循环，每次重新读取形参name的值。<br>形参n的值是一开始就采样好的，不会受影响，但形参name是每次都重新读取。那么就会受影响。</p><h1 id="11-误杀"><a href="#11-误杀" class="headerlink" title="11.误杀"></a>11.误杀</h1><p>disable xxx语句用于结束在当前层级空间中以xxx命名的所有线程。<br>层级可以是module，program，class等等。<br>xxx可以是任务名，也可以是语句块的名字。</p><p>这可能会造成意图杀死一个特定线程的同时，误杀共享同一命名的各个线程。<br>解决方法就是要分别命名。</p><h1 id="12-assertion竟会自己活过来"><a href="#12-assertion竟会自己活过来" class="headerlink" title="12.assertion竟会自己活过来"></a>12.assertion竟会自己活过来</h1><p>concurrent assertion被放在if-else中，即使条件为假，assertion也会被激活。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">property pty();</span><br><span class="line">  @(posedge clk)</span><br><span class="line">  b |-&gt; (c&gt;0);</span><br><span class="line">endproperty</span><br><span class="line"></span><br><span class="line">always @(posedge clk) begin</span><br><span class="line">  if(a) begin</span><br><span class="line">    assert(pty) $display(“assertion evaluated”);</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>代码逻辑很直接，但问题是即使a为0，assertion也会被激活。<br>这是因为对于被if-else做先导的concurrent assertion，先行算子其实有两个，一个是if另一个是property中的先行算子。<br>在例子中就是a &amp;&amp; b。在a=0的情况下，实际上是一个vacuous success。<br>所以if-else并不能过滤掉assertion的激活。</p><h1 id="13-永远等不到的property"><a href="#13-永远等不到的property" class="headerlink" title="13.永远等不到的property"></a>13.永远等不到的property</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">property p;</span><br><span class="line">  @(posedge clk)</span><br><span class="line">  a |→ #[1:$] b ##1 c</span><br><span class="line">endproperty</span><br></pre></td></tr></table></figure><p>根据上面的property定义，如果有一个这样的序列: a → 10 clk → b → 2 clk → c，它会检测到b和c之间两周期的错误吗？<br>答案是不会的。为什么这样？<br>这个property实际上是在看检测这样一个序列: a |-&gt; #[1:$] (b ##1 c)<br>这么一看就比较清楚了，它只是在等待一个(b ##1 c)的出现，如果出现了(b ##2 c)那根本不关心，因为不是想要等的。</p><p>解决办法有两个:</p><ol><li>把(b ##1 c)拆开，分成(a|-&gt; #[1:$] b)和(b |-&gt; ##1 c)两个就可以了</li><li>用[-&gt;1]操作符代替#[1:$] (b ##1 c)</li></ol></value></value></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>Post author:</strong> winter leaf</li><li class="post-copyright-link"> <strong>Post link:</strong> <a href="http://winter-leaf.github.io/gotcha%E8%AE%B0%E5%BD%95%E5%92%8C%E6%80%BB%E7%BB%93/" title="gotcha记录和总结">http://winter-leaf.github.io/gotcha%E8%AE%B0%E5%BD%95%E5%92%8C%E6%80%BB%E7%BB%93/</a></li><li class="post-copyright-license"> <strong>Copyright Notice:</strong> All articles in this blog are licensed under<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/null" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> unless stating additionally. Please indicate the source when reproduce.</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/gotcha/" rel="tag"># gotcha</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/uvm-register-model-%E5%89%8D%E9%97%A8%E6%93%8D%E4%BD%9C/" rel="next" title="uvm-register-model-前门操作"><i class="fa fa-chevron-left"></i> uvm-register-model-前门操作</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/A-small-portable-constraint-example/" rel="prev" title="A small portable constraint example">A small portable constraint example<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> Table of Contents</li><li class="sidebar-nav-overview"> Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-关于bit的迷思"><span class="nav-text">1.关于bit的迷思</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-位省略"><span class="nav-text">1.1 位省略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-位扩展"><span class="nav-text">1.2 位扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-变量运算"><span class="nav-text">1.3 变量运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-位选取"><span class="nav-text">1.4 位选取</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-异步条件优先级"><span class="nav-text">2.异步条件优先级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-enum默认初始值"><span class="nav-text">3.enum默认初始值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-missing-event-trigger"><span class="nav-text">4.missing event trigger</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-semaphore等待机制"><span class="nav-text">5.semaphore等待机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-wire-reg-logic"><span class="nav-text">6. wire,reg,logic</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-消失的函数返回值"><span class="nav-text">7.消失的函数返回值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-带默认值的形参只能放在ref类型形参前吗？"><span class="nav-text">8. 带默认值的形参只能放在ref类型形参前吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-消失的延时赋值语句"><span class="nav-text">9.消失的延时赋值语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-任务被自己侵犯了"><span class="nav-text">10.任务被自己侵犯了</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-误杀"><span class="nav-text">11.误杀</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-assertion竟会自己活过来"><span class="nav-text">12.assertion竟会自己活过来</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-永远等不到的property"><span class="nav-text">13.永远等不到的property</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="winter leaf" src="/images/avatar.jpeg"><p class="site-author-name" itemprop="name">winter leaf</p><div class="site-description" itemprop="description">Batman, if you don't believe it then superman</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <span class="site-state-item-count">9</span> <span class="site-state-item-name">categories</span></div><div class="site-state-item site-state-tags"> <span class="site-state-item-count">15</span> <span class="site-state-item-name">tags</span></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-gamepad"></i></span> <span class="author" itemprop="copyrightHolder">winter leaf</span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script></body></html>